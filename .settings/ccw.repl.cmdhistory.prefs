cmdhistory=["(lein ring server)" "(ring server)" "(app)" "(clojure.core/ns tictactoe.handler)\\n(ns tictactoe.handler\\r\\n  (\:use tictactoe.controller\\r\\n        compojure.core)\\r\\n  (\:require [noir.util.middleware \:as noir-middleware]\\r\\n            [compojure.route \:as route]))\\r\\n\\r\\n(defroutes app-routes\\r\\n  (route/resources \\"/\\")\\r\\n  (route/not-found \\"Not Found\\"))\\r\\n\\r\\n;;append your application routes to the all-routes vector\\r\\n(def all-routes [tictactoe-routes app-routes])\\r\\n\\r\\n(def app (-> all-routes\\r\\n             noir-middleware/app-handler\\r\\n             ;;add your middlewares here\\r\\n             ))\\r\\n\\r\\n(def war-handler (noir-middleware/war-handler app))\\r\\n\\n(clojure.core/ns user)" "(app)" "(tictactoe.handler/app)" "(app)" "app" "(require 'tictactoe.handler)" "(defproject tictactoe \\"0.1.1\\"\\r\\n  \:description \\"Tictactoe using ring, compojure, lib-noir and hiccup\\"\\r\\n  \:dependencies [[org.clojure/clojure \\"1.5.1\\"]\\r\\n                 [lib-noir \\"0.4.9\\"]\\r\\n                 [compojure \\"1.1.5\\"]\\r\\n                 [ring-server \\"0.2.7\\"]\\r\\n                 [hiccup \\"1.0.2\\"]]\\r\\n  \:ring {\:handler tictactoe.handler/war-handler}\\r\\n  \:profiles {\:production\\r\\n             {\:ring\\r\\n              {\:open-browser? false, \:stacktraces? false, \:auto-reload? false}}}\\r\\n  \:plugins [[lein-ring \\"0.8.3\\"]]\\r\\n  \:min-lein-version \\"2.0.0\\")\\r\\n\\r\\n" "(clojure.core/ns tictactoe.repl)\\n(ns tictactoe.repl\\r\\n  (\:use tictactoe.handler\\r\\n        ring.server.standalone\\r\\n        [ring.middleware file-info file]))\\r\\n\\r\\n(defonce server (atom nil))\\r\\n\\r\\n(defn get-handler []\\r\\n  ;; \#'app expands to (var app) so that when we reload our code,\\r\\n  ;; the server is forced to re-resolve the symbol in the var\\r\\n  ;; rather than having its own copy. When the root binding\\r\\n  ;; changes, the server picks it up without having to restart.\\r\\n  (-> \#'app\\r\\n    ; Makes static assets in $PROJECT_DIR/resources/public/ available.\\r\\n    (wrap-file \\"resources\\")\\r\\n    ; Content-Type, Content-Length, and Last Modified headers for files in body\\r\\n    (wrap-file-info)))\\r\\n\\r\\n(defn start-server\\r\\n  \\"used for starting the server in development mode from REPL\\"\\r\\n  [& [port]]\\r\\n  (let [port (if port (Integer/parseInt port) 8080)]\\r\\n    (reset\! server\\r\\n            (serve (get-handler)\\r\\n                   {\:port port                   \\r\\n                    \:auto-reload? true\\r\\n                    \:join true}))\\r\\n    (println (str \\"You can view the site at http\://localhost\:\\" port))))\\r\\n\\r\\n(defn stop-server []\\r\\n  (.stop @server)\\r\\n  (reset\! server nil))\\r\\n\\n(clojure.core/ns user)" "(start-server)" "(use tictactoe.repl)" "(use tictactoe.repl/start-server\\n     )" "(ns tictactoe.repl)" "(start-server)" "(tictactoe.model/play\!)" ";; Switching to tictactoe.view namespace" "(vec 1 2 3)" "(vec (1 2 3))" "(vec 1)" "(vec [1])" "(vec (1))" "(vec \\"string\\")" "'(1 2 3)" "''(1 2 3)" "('(1 2 3))" "(quote (1 2 3))" ";; Switching to lingo.repl namespace" "(start-server)" "(stop-server)" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" "(lingo.model/get-player)" "'(lingo.model/get-player)" "(lingo.model/get-player)" "(clojure.string/join (l i n g o))" "(clojure.string/join '(l i n g o))" "(clojure.string/join '(\\"string\\"))" "(clojure.string/split \\"string\\")" "(clojure.string/split the-word \\"\\\\d+\\")" "(clojure.core/ns lingo.model)\\n(def the-word \\"lingo\\")\\n(clojure.core/ns lingo.repl)" "(clojure.string/split the-word \\"\\\\d+\\")" "(clojure.string/split the-word \#\\"\\\\d+\\")" "(def the-word \\"lingo\\")" "(clojure.string/split the-word \#\\"\\\\d+\\")" "(clojure.string/split 'the-word \#\\"\\\\d+\\")" "(first \\"\\")" "(first \\"asd\\")" "(5th \\"asd\\")" "(5th \\"asd12\\")" "(nth 5 \\"asd12\\")" "(nth 5 \\"asdas\\")" "(nth 5 \\"asdasa\\")" "(seq \\"asdasa\\")" "(first (seq \\"asdasa\\"))" "(nth (seq \\"asdasa\\") 5)" "(nth (seq \\"asdasa\\") 4)" "(clojure.string/join (for [i 4]\\n                       (i)\\n                       (inc i))" "(clojure.string/join (for [i 4]\\n                       (i)\\n                       (inc i)))" "(clojure.string/join (for [i 4] (do\\n                       (i)\\n                       (inc i))))" "(clojure.string/join (for [i 4] \\n(                       (i)\\n                       (inc i))))" "(clojure.string/join (for [i 4] \\n                       ((i)\\n                       (inc i))))" "(clojure.core/ns lingo.model)\\nnull\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(def empty-board [[\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn is-in-word? [letter] (contains-char? (the-word) letter))\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn contains-char? [the-string, the-char]\\n  (some \#(\= the-char %) the-string))\\r\\n\\n(defn is-in-word? [letter] (contains-char? (the-word) letter))\\n  \\n\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(def empty-board [[\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(is-in-word? \\"i\\")\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn is-in-word? [letter] (contains-char? the-word letter))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(is-in-word? \\"i\\")\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(is-in-word? \\"i\\")\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn is-in-word? [letter] (contains-char? '(the-word) letter))\\n  \\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(is-in-word? \\"i\\")\\n(clojure.core/ns lingo.repl)" "is-in-word? \\"i\\"" "(clojure.core/ns lingo.model)\\n(defn contains-char? [the-string, the-char]\\n  (some \#(\= the-char %) the-string))\\r\\n\\n(defn is-in-word? [letter] (contains-char? '(the-word) letter))\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/is-in-word? \\"i\\")" "(lingo.model/is-in-word? \\\\i)" "(defn is-in-word? [letter] (contains-char? the-word letter))" "(defn contains-char? [the-string, the-char]\\r\\n  (some \#(\= the-char %) the-string))\\r\\n\\r\\n(defn is-in-word? [letter] (contains-char? the-word letter))" "(is-in-word? \\\\i)" "(is-in-word? \\\\a)" "(is-in-word? \\\\g\\n            )" "(take 1 \\"string\\")" "(take-nth [1 \\"string\\"])" "(take-nth 1 \\"string\\")" "(take-nth 2 \\"string\\")" "(\\"string\\" 1)" "((\\"string\\") 1)" "(.charAt \\"bitch\\" 1)" "(defn is-in-correct-place? [[x char] letter] \\r\\n  (\= (.charAt the-word x) char))" "(clojure.core/ns lingo.model)\\n(def empty-board [[\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]\\r\\n                  [\\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(def test-letter-i 1 \\\\i)\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(def test-letter-i [1 \\\\i])\\n(clojure.core/ns lingo.repl)" "(is-in-correct-place? lingo.model/test-letter-i)" ";; Switching to lingo.model namespace" "\\n(defn contains-char? [the-string, the-char]\\n  (some \#(\= the-char %) the-string))\\r\\n\\n(defn is-in-word? [letter] (contains-char? the-word letter))\\n\\n(defn is-in-correct-place? [[x char] letter] \\n  (\= (.charAt the-word x) char))\\n\\n(def test-letter-i [1 \\\\i])\\n\\n" "(is-in-correct-place? test-letter-i)" "(let [[x char] letter)" "(let [[x char] test-letter-i]\\n  println(x char))" "(def point [5 7])" "(let [[x char] test-letter-i]\\n  println x char)" "(let [[x char] test-letter-i]\\n  println x)" "(let [[x char] test-letter-i]\\n  println x + char)" "(let [[x char] test-letter-i]\\n  (println \\"x\:\\" x \\"y\:\\" char))" "(.charAt the-word 1)" "(let [[x char] test-letter-i]\\n  (\= (.charAt the-word x) char)" "(let [[x char] test-letter-i]\\n  (\= (.charAt the-word x) char))" "(is-in-correct-place? test-letter-i)" "(defn is-in-correct-place? [[[x char] letter]] \\r\\n  (\= (.charAt the-word x) char))" "(is-in-correct-place? test-letter-i)" "(defn is-in-correct-place? [[x char] letter] \\n  (\= (.charAt (the-word) x) char))\\n" "(is-in-correct-place? test-letter-i)" "(defn is-in-correct-place? [letter]\\r\\n  (let [[x char] letter]\\r\\n    (\= (.charAt the-word x) char)))" "(is-in-correct-place? test-letter-i)" "(is-in-correct-place? [0 \\\\l])" "(is-in-correct-place? [0 \\\\2])" ";; Switching to tictactoe.repl namespace" ";; Switching to lingo.repl namespace" ";; Switching to lingo.model namespace" ";; Switching to lingo.repl namespace" "(clojure.core/ns lingo.model)\\nnull\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.model namespace" ";; Switching to lingo.repl namespace" ";; Switching to lingo.model namespace" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server 5050)" "(start-server)(" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.view namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.string/split \\"lingo\\" \#\\"\\\\d+\\")" "(clojure.string/split \\"q1w2e3r4t5y6u7i8o9p0\\" \#\\"\\\\d+\\")" "(clojure.string/split \\"lingo\\" \#\\"\\\\d+\\")" "(clojure.string/split \\"lingo\\" \#\\"\\")" "(clojure.string/split \\"lingo\\" \\"\\")" "(clojure.string/split \\"lingo\\" \#\\"\\")" "(clojure.string/split \#\\"lingo\\" \#\\"\\")" "(clojure.string/split '\\"lingo\\" \#\\"\\")" "(clojure.string/split \\"lingo\\")" "(clojure.string/split \\"lingo\\" \\\\)" "(clojure.string/split \\"lingo\\" \\\\))" "(clojure.string/split \\"lingo\\" \\\\\\"\\")" "(clojure.string/split \\"lingo\\" \\\\\#\\"\\")" "(clojure.string/split \\"lingo\\" \#\\"\\")" "(butlast(reverse(clojure.string/split \\"lingo\\" \#\\"\\")))" "(drop 1 (clojure.string/split \\"lingo\\" \#\\"\\"))" "(for [x (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\")] (x))" "(for (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") (x))" "(for '(\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") )" "(seq (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(seq '(\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(for [x1 [\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"] x2 [\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"]] (str x1 x2))" "(for [x1 (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") x2 (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\")] (str x1 x2))" "(to-array (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(vector (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(vec (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(zipmap (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(vec '(\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\"))" "(for [x1 (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") x2 (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\")] (str x1 x2))" "(for [x1 (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") x2 '(\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\")] (str x1 x2))" "(for [x1 ' (\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\") x2 '(\\"l\\" \\"i\\" \\"n\\" \\"g\\" \\"o\\")] (str x1 x2))" "(clojure.core/ns lingo.model)\\n\\n(defn place-correct-letters [guess word]\\n  (for [x1 (split-word guess)] (if is-in-word? x1) (println x1) (println \\"not\\")))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn place-correct-letters [guess word]\\n  (for [x1 (split-word guess)] (if (is-in-word? x1) (println x1) (println \\"not\\"))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn place-correct-letters [guess word]\\n  (for [x1 (split-word guess)] (if (is-in-word? x1) (println x1) (println \\"not\\"))))\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn split-word [word] \\n  ((drop 1 (clojure.string/split word \#\\"\\"))))\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn place-correct-letters [guess word]\\n  (for [x1 (split-word guess)] (if (is-in-word? x1) (println x1) (println \\"not\\"))))\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/place-correct-letters \\"linas\\" \\"lingo\\")" "(clojure.core/ns lingo.model)\\n\\n(defn split-word [word] \\n  ((drop 1 (clojure.string/split 'word \#\\"\\"))))\\n(clojure.core/ns lingo.repl)" "(lingo.model/place-correct-letters \\"linas\\" \\"lingo\\")" "(lingo.model/split-word \\"asd\\")" "(clojure.core/ns lingo.model)\\n\\n(defn split-word [word] \\n  ((drop 1 (clojure.string/split word \#\\"\\"))))\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/split-word \\"asd\\")" "(clojure.core/ns lingo.model)\\n\\n(defn split-word [word] \\n  (clojure.string/split word \#\\"\\"))\\n(clojure.core/ns lingo.repl)" "(lingo.model/split-word \\"asd\\")" "(clojure.core/ns lingo.model)\\n(defn split-word [word] \\n  ((drop 1 '(clojure.string/split word \#\\"\\"))))\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/split-word \\"asd\\")" "(drop 1 (clojure.string/split \\"\\" \#\\"\\"))" "(drop 1 (clojure.string/split \\"yes\\" \#\\"\\"))" "(drop 1 (clojure.string/split '\\"yes\\" \#\\"\\"))" "(drop 1 (clojure.string/split lingo.model/the-word \#\\"\\"))" "(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))" "(lingo.model/split-word \\"asd\\")" "(clojure.core/ns lingo.model)\\n(defn split-word [word] \\n  (drop 1 (clojure.string/split word \#\\"\\")))\\n(clojure.core/ns lingo.repl)" "(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))" "(lingo.repl/split-word \\"test\\")" ";; Switching to lingo.model namespace" "(place-correct-letters \\"linko\\" \\"lingo\\")" "(defn place-correct-letters [guess word]\\r\\n  (for [x1 (split-word guess)] (if (is-in-word? x1) (println x1) (println x1))))\\r\\n" "(place-correct-letters \\"linko\\" \\"lingo\\")" ";; Switching to lingo.model namespace" "(place-correct-letters \\"linko\\" \\"lingo\\")" "(defn place-correct-letters [guess the-word]\\r\\n  (for [x1 (split-word guess)] (if (is-in-word? x1 the-word) (println x1 \\"yes\\") (println x1))))\\r\\n" "(place-correct-letters \\"linko\\" \\"lingo\\")" "(defn place-correct-letters [guess the-word]\\r\\n  (for [x1 (split-word guess)] (if (is-in-word? x1 the-word) (println x1 \\"yes\\") (println x1 \\"no\\"))))\\r\\n" "(place-correct-letters \\"linko\\" \\"lingo\\")" "(ns lingo.model\\r\\n  (\:require [noir.session \:as session]))\\r\\n\\n(def empty-board [[\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n\\n(def init-state {\:board empty-board})\\n\\n(defn get-board []\\n  (\:board (session/get \:game-state)))\\n\\n(defn get-board-letter\\n  ([row col]\\n    (get-board-letter row col (get-board)))\\n  ([row col board]\\n    (get-in board [row col])))\\n\\n(defn play-word\\n  ([word] (play-word word get-board))\\n  ([word board] ()))\\n\\n(defn contains-char? [the-char, the-string]\\n  (some \#(\= the-char %) the-string))\\r\\n\\r\\n(defn is-in-word? [letter the-word] (contains-char? letter the-word))\\r\\n\\n(defn is-in-correct-place? [letter the-word]\\n  (let [[x char] letter]\\n    (\= (.charAt the-word x) char)))\\n\\n(def test-letter-i [1 \\\\i])\\n\\n(def get-word \\"word\\")\\n\\n(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))\\r\\n\\r\\n(defn place-correct-letters [guess the-word]\\r\\n  (for [x1 (split-word guess)] (if (is-in-word? x1 the-word) (println x1 \\"yes\\") (println x1 \\"no\\"))))\\r\\n\\n(defn winner? \\n  ([guess] (winner? guess (get-word)))\\n  ([guess word] (winner? guess word (get-board)))\\n  ([guess word board] (if (\= guess word)\\n                        ()\\n                        (place-correct-letters guess word))))\\n\\n\\n(defn reset-game\! [] \\r\\n  (session/put\! \:game-state init-state))\\r\\n\\r\\n(defn new-state [row col letter old-state]\\r\\n    {\:board (assoc-in (\:board old-state) [row col] (\:player old-state))}\\r\\n    old-state)\\r\\n\\r\\n(defn play\! [row col]\\r\\n  (session/swap\! (fn [session-map]\\r\\n                   (assoc session-map \:game-state \\r\\n                          (new-state row col (\:game-state session-map))))))\\n\\n(defn full-board?\\r\\n  ([] (full-board? (get-board)))\\r\\n  ([board] (let [all-cells (apply concat board)]\\r\\n             (not-any? \#(\= % \\\\-) all-cells))))\\n\\r\\n;(def empty-board [[\\\\- \\\\- \\\\-]\\r\\n;                  [\\\\- \\\\- \\\\-]\\r\\n;                  [\\\\- \\\\- \\\\-]])\\r\\n;\\r\\n;(def init-state {\:board empty-board \:player \\\\X})\\r\\n;\\r\\n;(defn reset-game\! []\\r\\n;  (session/put\! \:game-state init-state))\\r\\n;\\r\\n;(defn get-board []\\r\\n;  (\:board (session/get \:game-state)))\\r\\n;\\r\\n;(defn get-board-cell \\r\\n;  ([row col]\\r\\n;    (get-board-cell (get-board) row col))\\r\\n;  ([board row col]\\r\\n;    (get-in board [row col])))\\r\\n;\\r\\n;(defn get-player []\\r\\n;  (\:player (session/get \:game-state)))\\r\\n;\\r\\n;(defn other-player \\r\\n;  ([] (other-player (get-player)))\\r\\n;  ([player] (if (\= player \\\\X) \\\\O \\\\X)))\\r\\n;\\r\\n;(defn winner-in-rows? [board player]\\r\\n;  (boolean (some (fn [row] (every? (fn [c] (\= c player)) row)) board)))\\r\\n;\\r\\n;(defn transposed-board [board]\\r\\n;  (vec (apply map vector board)))\\r\\n;\\r\\n;(defn winner-in-cols? [board player]\\r\\n;  (winner-in-rows? (transposed-board board) player))\\r\\n;\\r\\n;(defn winner-in-diagonals? [board player]\\r\\n;  (let [diag-coords [[[0 0] [1 1] [2 2]]\\r\\n;                     [[0 2] [1 1] [2 0]]]]\\r\\n;    (boolean (some (fn [coords] \\r\\n;                     (every? (fn [coord] \\r\\n;                               (\= player (apply get-board-cell board coord))) \\r\\n;                             coords))\\r\\n;                   diag-coords))))\\r\\n;\\r\\n;(defn winner?\\r\\n;  \\"checks if there is a winner. when called with no args, checks for player X and player O.\\r\\n;returns the character for the winning player, nil if there is no winner\\"\\r\\n;  ([] (winner? (get-board)))\\r\\n;  ([board]\\r\\n;    (boolean (or (winner? board \\\\X)\\r\\n;                 (winner? board \\\\O))))\\r\\n;  ([board player]\\r\\n;    (if (or (winner-in-rows? board player)\\r\\n;            (winner-in-cols? board player)\\r\\n;            (winner-in-diagonals? board player))\\r\\n;      player)))\\r\\n;\\r\\n;(defn full-board?\\r\\n;  ([] (full-board? (get-board)))\\r\\n;  ([board] (let [all-cells (apply concat board)]\\r\\n;             (not-any? \#(\= % \\\\-) all-cells))))\\r\\n;\\r\\n;(defn new-state [row col old-state]\\r\\n;  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\r\\n;           (not (winner? (\:board old-state))))\\r\\n;    {\:board (assoc-in (\:board old-state) [row col] (\:player old-state))\\r\\n;     \:player (other-player (\:player old-state))}\\r\\n;    old-state))\\r\\n;\\r\\n;(defn play\! [row col]\\r\\n;  (session/swap\! (fn [session-map]\\r\\n;                   (assoc session-map \:game-state \\r\\n;                          (new-state row col (\:game-state session-map))))))\\n\\n " "(place-correct-letters \\"linko\\" \\"lingo\\")" "(\:b {\:a 10 \:b 20 \:c 30})" "(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))\\n\\r\\n(defn combine-into-letters [split-word] (for [x [split-word]\\n                                         y [0 1 2 3 4]\\n                                         [x y]]))\\n" "(defn combine-into-letters [split-word] (for [x [split-word]\\r\\n                                         y [0 1 2 3 4]\\r\\n                                         [x y]]))" "(defn combine-into-letters [split-word] (for [x [split-word]\\r\\n                                         y [0 1 2 3 4]]\\r\\n                                         [x y]))" "(combine-into-letters (split-word \\"tests\\"))" "(defn combine-into-letters [split-word] (for [x ['split-word]\\r\\n                                            y [0 1 2 3 4]]\\r\\n                                            [x y]))" "(combine-into-letters (split-word \\"tests\\"))" "(split-word \\"tests\\")" "(split-word '\\"tests\\")" "\\n(defn split-word [word] \\r\\n  [(drop 1 (clojure.string/split word \#\\"\\"))])" "(split-word \\"tests\\")" "\\n(defn split-word [word] \\r\\n  (drop 1 [(clojure.string/split word \#\\"\\")]))\\n" "(split-word \\"tests\\")" "(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split [word] \#\\"\\")))\\n" "(split-word \\"tests\\")" "(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))\\n" "(merge (split-word \\"tests\\") [1 2 3 4 5])" "(zipmap (split-word \\"tests\\") [0 1 2 3 4])" "(zip (split-word \\"tests\\") [0 1 2 3 4])" "(map vector [1 2 3] [4 5 6])" "(map vector (split-word \\"tests\\") [0 1 2 3 4])" "(defn combine-into-letters [split-word] (map vector split-word [0 1 2 3 4]))" "(combine-into-letters \\"tests\\")" "(for [x (combine-into-located-letters \\"tests\\")] x)" "(defn contains-char? [the-char, the-string]\\n  (some \#(\= the-char %) the-string))\\r\\n\\r\\n(defn is-in-word? [letter the-word] (contains-char? letter the-word))\\r\\n\\n(defn is-in-correct-place? [located-letter the-word]\\n  (let [[x char] located-letter]\\n    (\= (.charAt the-word x) char)))\\n\\n(def test-letter-i [1 \\\\i])\\n\\n(def get-word \\"word\\")\\n\\n(defn split-word [word] \\r\\n  (drop 1 (clojure.string/split word \#\\"\\")))\\n\\r\\n(defn combine-into-located-letters [split-word] (map vector split-word [0 1 2 3 4]))\\n\\r\\n(defn place-correct-letters [guess the-word] ()  )\\r\\n" "(for [x (combine-into-located-letters \\"tests\\")])" "(for [x (combine-into-located-letters \\"tests\\")] x)" "(for [x (combine-into-located-letters \\"tests\\")] \\n  (is-in-correct-place? x))" "(for [x (combine-into-located-letters \\"tests\\")] \\n  (is-in-correct-place? x \\"tesds\\"))" "(defn is-in-correct-place? [located-letter the-word]\\n  (let [[char x] located-letter]\\n    (\= (.charAt the-word x) char)))" "(for [x (combine-into-located-letters \\"tests\\")] \\n  (is-in-correct-place? x \\"tesds\\"))" "\\r\\n(defn place-correct-letters [guess the-word] \\n  (for [x (combine-into-located-letters guess)]\\n    (is-in-correct-place? x word)))" "(defn place-correct-letters [guess the-word] \\n  (for [x (combine-into-located-letters guess)]\\n    (is-in-correct-place? x the-word)))" "(def init-state {\:board empty-board \:the-word (get-word)})\\n" "\\n(def init-state {\:board empty-board \:the-word (get-word)})\\n" "\\n(def init-state {\:board empty-board \:the-word get-word})\\n" "\\n(def init-state {\:board empty-board \:the-word get-word \:turn 1})\\n" ";; Switching to lingo.model namespace" ";; Switching to lingo.repl namespace" "(START-server)" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn winner? \\n  ([guess] (winner? guess (get-word)))\\n  ([guess word] (winner? guess word (get-board)))\\n  ([guess word board] (if (\= guess word)\\n                        (true)\\n                        (false))))\\n(clojure.core/ns lingo.repl)" "(get-word)" "(lingo.model/get-word)" "(clojure.core/ns lingo.model)\\n\\n(def get-word (\\"lingo\\"))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(def get-word \\"lingo\\")\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/get-word)" "lingo.model/get-word" "(clojure.core/ns lingo.model)\\n(defn get-word (\\"lingo\\"))\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn get-word [] (\\"lingo\\"))\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/get-word)" "(clojure.core/ns lingo.model)\\n\\n(defn get-word [] \\"lingo\\")\\n(clojure.core/ns lingo.repl)" "(lingo.model/get-word)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n\\n(defn winner? \\n  ([guess] (winner? guess (get-word)))\\n  ([guess word] (winner? guess word (get-board)))\\n  ([guess word board] (if (\= guess word)\\n                        true\\n                        false)))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.controller)\\n\\r\\n(defn turn-page [submit]\\n    ((println (\:word submit))\\r\\n    (model/play\! (\:word submit))\\r\\n    (if-let [winner (model/winner? word)]\\r\\n      (view/winner-screen winner)\\r\\n      (if (model/full-board?)\\r\\n        (view/draw-screen)\\r\\n        (view/play-screen)))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.controller)\\n\\r\\n(defn turn-page [submit]\\n    ((println (\:word submit))\\r\\n    (model/play\! (\:word submit))\\r\\n    (if-let [winner (model/winner? (\:word submit))]\\r\\n      (view/winner-screen winner)\\r\\n      (if (model/full-board?)\\r\\n        (view/draw-screen)\\r\\n        (view/play-screen)))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println char x located-letter (\:board old-state))\\n                (assoc-in (\:board old-state)\\n                      [count x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println char x located-letter (old-state \:board))\\n                (assoc-in (\:board old-state)\\n                      [count x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println char x located-letter (old-state))\\n                (assoc-in (\:board old-state)\\n                      [count x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println char x located-letter)\\n                (assoc-in (\:board old-state)\\n                      [count x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println located-letter (\:board old-state))\\n                (assoc-in (\:board old-state)\\n                      [count x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn play\! [word]\\r\\n  (session/swap\! (fn [session-map]\\r\\n                   (assoc  session-map \:game-state \\r\\n                          (new-state word (\:game-state session-map))))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (\:turn old-state) x)\\n                (assoc-in (\:board old-state)\\n                      [ x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (\:turn old-state) x)\\n                (assoc-in (\:board old-state)\\n                      [(\:turn old-state) x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn reset-game\! [] \\r\\n  (session/put\! \:game-state init-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (\:turn old-state) \\n                          x \\n                          char\\n                          (get-in (\:board old-state) \\n                                  [(\:turn old-state) 1]))\\n                (assoc-in (\:board old-state)\\n                      [(\:turn old-state) x] char))))\\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (\:turn old-state) \\n                          x \\n                          char\\n                          (get-in (\:board old-state) \\n                                  [(\:turn old-state) 1]))\\n                (assoc-in (\:board old-state)\\n                          \\n                      [(\:turn old-state) x] char))))\\n     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n                                  [(\:turn old-stat\\n(clojure.core/ns lingo.repl)" "(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (\:turn old-state) \\n                          x \\n                          char\\n                          (get-in (\:board old-state) \\n                                  [(\:turn old-state) 1]))\\n                (assoc-in (\:board old-state)\\n                          \\n                      [(\:turn old-state) x] char))))\\n     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))" ";; Switching to lingo.model namespace" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                ((println (dec (\:turn old-state))\\n                          x \\n                          char\\n                          (get-in (\:board old-state) \\n                                  [(dec (\:turn old-state)) 1]))\\n                (\:board old-state \\n                        (assoc-in (\:board old-state)                          \\n                      [(dec (\:turn old-state)) x] char)))))\\n     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (for [located-letter (combine-into-located-letters word)]\\n              (let [[char x] located-letter]\\n                (assoc-in (\:board old-state)                          \\n                      [(dec (\:turn old-state)) x] char)))}\\n     \\r\\n     {\:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state)\\n                      (for [located-letter (combine-into-located-letters word)]\\n                        (let [[char x] located-letter]\\n                      [(dec (\:turn old-state)) x] char)))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state)\\n                      (combine-into-located-letters word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state)\\n                      [(dec(\:turn old-state)) 0](combine-into-located-letters word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.controller)\\n\\r\\n(defn turn-page [submit]\\n    (\\n      (model/play\! (\:word submit))\\n      (if-let [winner (model/winner? (\:word submit))]\\n        (view/winner-screen winner)\\n        (if (model/full-board?)\\n          (view/draw-screen)\\n          (view/play-screen)))))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.controller)\\n(defroutes tictactoe-routes\\r\\n  (GET \\"/\\" [] (start-page))\\r\\n  (POST \\"/\\" {submit \:params} (turn-page submit)))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.controller)\\n\\r\\n(defn turn-page [submit]\\n    (\\n      (model/play\! (\:word submit))\\n      (if-let [winner (model/winner? (\:word submit))]\\n        (view/winner-screen winner)\\n        (if (model/full-board?)\\n          ((println (view/draw-screen))(view/draw-screen))\\n          ((println (view/play-screen))(view/play-screen))))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.controller)\\n(defn turn-page [submit]\\n    (\\n      (model/play\! (\:word submit))\\n      (if-let [winner (model/winner? (\:word submit))]\\n        (view/winner-screen winner)\\n        (if (model/full-board?)\\n          ((println (view/draw-screen))(view/draw-screen))\\n          ((println (view/play-screen))(view/play-screen))))))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(combine-into-located-letters \\"test\\")" "(lingo.model/combine-into-located-letters \\"test\\")" "(lingo.model/split-word \\"linko\\")" "(clojure.core/ns lingo.controller)\\n(defn turn-page [submit]\\n    ((model/play\! (\:word submit))(if-let [winner (model/winner? (\:word submit))]\\n        (view/winner-screen winner)\\n        (if (model/full-board?)\\n          ((println (view/draw-screen))(view/draw-screen))\\n          ((println (view/play-screen))(view/play-screen))))))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.controller)\\nnull\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(clojure.core/ns lingo.controller)\\n(defroutes tictactoe-routes\\r\\n  (GET \\"/\\" [] (start-page))\\r\\n  (POST \\"/\\" {button-pressed \:params} (turn-page button-pressed)))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" ";; Switching to lingo.model namespace" "(start" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 6))\\r\\n           (not (winner? word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(clojure.core/ns lingo.model)\\n(def init-state {\:board empty-board \:the-word get-word \:turn 0})\\n(clojure.core/ns lingo.repl)" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? word))\\n           (not (< 5(count word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? word))\\n           (not (< 5(count word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))" "(defn new-state [word old-state]\\n  (if (and (not (\= (\:turn old-state) 5))\\r\\n           (not (winner? word))\\n           (not (< 5(count word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state)))\\r\\n" "(defn play\! [word]\\r\\n  (session/swap\! (fn [session-map]\\r\\n                   (assoc  session-map \:game-state \\r\\n                          (new-state word (\:game-state session-map))))))" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (every? \\n        (not (\= (\:turn old-state) 5))(not (winner? word))\\n           (not (< 5 (count word))))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and \\n        (not (\= (\:turn old-state) 5))\\n        (not (winner? word))\\n        (< 5 (count word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and \\n        (not (\= (\:turn old-state) 5))\\n        (not (winner? word)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn new-state [word old-state]\\n  (if (and \\n        (not (\= (\:turn old-state) 5))\\n        (not (winner? word))\\n        (not (< (count word) 5)))\\n    {\:board (assoc (\:board old-state)\\n                   (\:turn old-state)\\n                    (split-word word))     \\r\\n     \:turn (inc (\:turn old-state))}\\r\\n    old-state))\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn put-first-letter-on-board \\n  ([] (put-first-letter-on-board get-word get-board))\\n  ([word board] (assoc-in board [0 0] (first word))))\\n\\n(clojure.core/ns lingo.repl)" "(first \\"string\\")" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn put-first-letter-on-board \\r\\n  ([] (put-first-letter-on-board get-word))\\r\\n  ([word] {\:board (assoc-in empty-board [0 0] (first word))}))\\r\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n\\n(def init-state {\:board put-first-letter-on-board \:the-word get-word \:turn 0})\\n\\n(clojure.core/ns lingo.repl)" "(session/get \:game-state)" "(noir.session/get \:game-state)" "\:board (noir.session/get \:game-state)" "(\:board (noir.session/get \:game-state))" "{\:board (noir.session/get \:game-state)}" "(clojure.core/ns lingo.model)\\n(defn get-word [] \\"lingo\\")\\r\\n\\n(def init-board [[(first(get-word)) \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(init-board)" "init-board" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n\\n(defn word-with-correctness [word]\\n  (let [word-seq (split-word word)]\\n    apply map vector [[word-seq]\\n                     [(is-in-word? word-seq)]\\n                     [(is-in-correct-place? word-seq)]]))\\n                      \\n(clojure.core/ns lingo.repl)" "(lingo.model/word-with-correctness \\"tests\\")" "(clojure.core/ns lingo.model)\\n\\n(defn word-with-correctness [word]\\n  (let [word-seq (split-word word)]\\n    apply map vector [[word-seq]\\n                     [(correct-letters word the-word)]\\n                     [(letters-in-word word the-word)]]))\\n                      \\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(defn word-with-correctness [word]\\n  (let [word-seq (split-word word)]\\n    apply map vector [[word-seq]\\n                     [(correct-letters word get-word)]\\n                     [(letters-in-word word get-word)]]))\\n                      \\n  \\n(clojure.core/ns lingo.repl)" "(lingo.model/word-with-correctness \\"tests\\")" "(clojure.core/ns lingo.model)\\n(defn word-with-correctness [word]\\n  (let [word-seq (split-word word)]\\n    apply map vector [[word-seq]\\n                     [(correct-letters word (get-word))]\\n                     [(letters-in-word word (get-word))]]))\\n(clojure.core/ns lingo.repl)" "(lingo.model/word-with-correctness \\"tests\\")" "(lingo.model/word-with-correctness \\"linko\\")" "(lingo.model/letters-in-word \\"lingo\\" \\"linjo\\"" "(lingo.model/letters-in-word \\"lingo\\" \\"linjo\\")" "  (for [x (combine-into-located-letters guess)]\\r\\n    (is-in-word? x the-word)" "  (for [x (combine-into-located-letters \\"linko\\")]\\r\\n    (is-in-word? x \\"lingo\\"))" "  (for [x (combine-into-located-letters \\"linko\\")]\\r\\n    (lingo.model/is-in-word? x \\"lingo\\"))" "  (for [x (lingo.model/combine-into-located-letters \\"linko\\")]\\r\\n    (lingo.model/is-in-word? x \\"lingo\\"))" "(lingo.model/is-in-word? l \\"lingo\\")" "(lingo.model/is-in-word? \\\\l \\"lingo\\")" "(for [x (lingo.model/combine-into-located-letters \\"linko\\")]\\n  (x))" "(for [x (lingo.model/combine-into-located-letters \\"linko\\")]\\n  x)" "(for [[char x] (lingo.model/combine-into-located-letters \\"linko\\")]\\n  x)" "(for [[char x] (lingo.model/combine-into-located-letters \\"linko\\")]\\n  char)" "(clojure.core/ns lingo.model)\\n(defn letters-in-word [guess the-word]\\n  (for [[char x] (combine-into-located-letters guess)]\\n    (is-in-word? char the-word)))\\n(clojure.core/ns lingo.repl)" "(lingo.model/letters-in-word \\"linko\\" \\"lingo\\")" ";; Switching to lingo.model namespace" "(word-with-correctness \\"linko\\")" "(defn get-board-letter\\n  ([row col]\\n    (get-board-letter row col (get-board)))\\n  ([row col board]\\n    (get-in board [row col])))" "(word-with-correctness \\"linko\\")" "(defn word-with-correctness [word]\\n    (apply map vector \\n           [[(split-word word)]\\n            [(correct-letters word (get-word))]\\n            [(letters-in-word word (get-word))]]))" "(defn word-with-correctness [word]\\r\\n    (apply map vector \\r\\n           [[(split-word word)]\\r\\n            [(correct-letters word (get-word))]\\r\\n            [(letters-in-word word (get-word))]]))" "(word-with-correctness \\"linko\\" \\"lingo\\")" "(word-with-correctness \\"linko\\")" "(defn word-with-correctness [word]\\r\\n    (apply map vector \\r\\n           [(split-word word)\\r\\n            (correct-letters word (get-word))\\r\\n            (letters-in-word word (get-word))]))" "(word-with-correctness \\"linko\\")" "(first (word-with-correctness \\"linko\\"))" "(first(first (word-with-correctness \\"linko\\")))" "(ffirst (word-with-correctness \\"linko\\"))" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.view)\\n\\n(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\n            \:class (if (\= (second (str cell) \\\\[)) \\"tile inword\\" \\"tile\\")}\\n    [\:h1 (str cell)]]])\\n(clojure.core/ns lingo.repl)" "(defn word-with-correctness [word]\\r\\n    (apply map vector \\r\\n           [(split-word word)\\r\\n            (correct-letters word (get-word))\\r\\n            (letters-in-word word (get-word))]))" ";; Switching to lingo.model namespace" "(word-with-correctness \\"linko\\")" "(split-word \\"linko\\")" "(nth (first(word-with-correctness \\"linko\\"))3)" "(nth (first(word-with-correctness \\"linko\\"))2)" "(clojure.core/ns Week3)\\n(interleave [\:first \:second \:third] [1 2 3])\\n(clojure.core/ns lingo.model)" "(clojure.core/ns Week3)\\n(interleave [\:first \:second \:third] [1 2 3] [4 5 6])\\n(clojure.core/ns lingo.model)" "(map-indexed interleave word-with-correctness)" "(map-indexed interleave (word-with-correctness \\"linko\\"))" "(word-with-correctness \\"linko\\")" "(first(word-with-correctness \\"linko\\"))" "(map first (word-with-correctness \\"linko\\"))" "(map (comp first second)(word-with-correctness \\"linko\\"))" "(map (complement first second)(word-with-correctness \\"linko\\"))" "(map (compl first second)(word-with-correctness \\"linko\\"))" "(map (compl first second) [[1 2][3 4]])" "(map (comp first second) [[1 2][3 4]])" "(map (comp first second) ())" "(map (comp first second) [1 2])" "(map (comp first second) ([1 2] [3 4]))" "([1 2] [3 4])" "(map (comp first second) [1 2])" "(map (comp first second) (1 2))" "(map (comp first second) 1 2)" "(map (comp first second) ([1 2]))" "(word-with-correctness \\"linko\\")" "(first(word-with-correctness \\"linko\\"))" "(for [x 5] (nth (word-with-correctness \\"linko\\") x))" "(for [x 4] (nth (word-with-correctness \\"linko\\") x))" "(for [x 4] (println x) x)" "(for [x 4] (println x))" "(for [x (range 5)] (println x))" "(for [x (range 5)] (println x)x)" "(for [x (range 5)] x)" "(for [x (range5)] (nth (word-with-correctness \\"linko\\") x))" "(for [x (range 5)] (nth (word-with-correctness \\"linko\\") x))" "(for [x (range 5)] (nth (word-with-correctness \\"ligjo\\") x))" "(for [x (range 5)] ((first nth (word-with-correctness \\"ligjo\\") )))" "(for [x (range 5)] ((first (nth (word-with-correctness \\"ligjo\\") ))))" "(for [x (range 5)] ((first (nth (word-with-correctness \\"ligjo\\") x))))" "(for [x (range 5)] ((first (nth (word-with-correctness \\"ligjo\\") )x)))" "(for [x (range 5)] ((first (nth (word-with-correctness \\"ligjo\\") x))))" "(for [x (range 5)] ((nth (word-with-correctness \\"ligjo\\") x)))" "(for [x (range 5)] (nth (word-with-correctness \\"ligjo\\") x))" "(for [x (range 5)] (first(nth (word-with-correctness \\"ligjo\\") )x))" "(for [x (range 5)] (first(nth (word-with-correctness \\"ligjo\\") x)))" "(for [x (range 5)] (second(nth (word-with-correctness \\"ligjo\\") x)))" "(for [x (range 5)] (str (first (nth (word-with-correctness \\"ligjo\\") x)(second(nth (word-with-correctness \\"ligjo\\") x)))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x)\\n                     (second(nth (word-with-correctness \\"ligjo\\") x)))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (second(nth (word-with-correctness \\"ligjo\\") x))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     ((if (second(nth (word-with-correctness \\"ligjo\\") x))\\n                        \\\\[\\n                        )))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     ((if (second(nth (word-with-correctness \\"ligjo\\") x))\\n                        \\\\[\\n                        ))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     ((if (second(nth (word-with-correctness \\"ligjo\\") x))\\n                        \\\\[\\n                        \\"\\"))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (second(nth (word-with-correctness \\"ligjo\\") x))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (second (nth (word-with-correctness \\"ligjo\\") x))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x)))))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\"true\\")))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\"[\\")))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\"\\n                       \\"]\\")))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\"\\n                       \\"\\")))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")))" "(second \\"\\")" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (word-with-correctness \\"ligjo\\") 3))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (nth (word-with-correctness \\"ligjo\\") x)3))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (nth (word-with-correctness \\"ligjo\\") x) 3))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (nth (word-with-correctness \\"ligjo\\") x) 3)))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (nth (word-with-correctness \\"ligjo\\")x)3)))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (nth (nth (word-with-correctness \\"ligjo\\") x) 2)))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (if (nth (nth (word-with-correctness \\"ligjo\\") x) 2))\\n                     \\"]\\"))" "(for [x (range 5)] (str \\n                     (first (nth (word-with-correctness \\"ligjo\\") x))\\n                     (if (second (nth (word-with-correctness \\"ligjo\\") x))\\n                       \\"[\\")\\n                     (if (nth (nth (word-with-correctness \\"ligjo\\") x) 2)\\n                       \\"]\\")\\n                     ))" "(defn word-with-correctness [word]\\r\\n    (let [guess (apply map vector \\r\\n           [(split-word word)\\r\\n            (correct-letters word (get-word))\\r\\n            (letters-in-word word (get-word))])]\\r\\n      (for [x (range 5)] (str \\r\\n                     (first (nth (word-with-correctness guess) x))\\r\\n                     (if (second (nth (word-with-correctness guess x))\\r\\n                       \\"[\\")\\r\\n                     (if (nth (nth (word-with-correctness guess) x) 2)\\r\\n                       \\"]\\")\\r\\n                     )))))" "(word-with-correctness \\"lingjo\\")" "(defn word-with-correctness [word]\\r\\n    (let [guess (apply map vector \\r\\n           [(split-word word)\\r\\n            (correct-letters word (get-word))\\r\\n            (letters-in-word word (get-word))])]\\r\\n      (for [x (range 5)] (str \\r\\n                     (first (nth guess x))\\r\\n                     (if (second (nth guess x))\\r\\n                       \\"[\\")\\r\\n                     (if (nth (nth guess x) 2)\\r\\n                       \\"]\\")\\r\\n                     ))))" "(word-with-correctness \\"lingjo\\")" "(word-with-correctness \\"linjo\\")" ";; Switching to lingo.repl namespace" "(start-server)" "(if (\= (second (str \\"p[\\") \\\\[)) \\r\\n                     \\"tile inword\\" \\r\\n                     \\"tile\\")" "(clojure.core/ns lingo.view)\\n\\n(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\n            \:class (if (\= (second (str cell) \\\\[)) \\n                     \\"tile inword\\" \\n                     \\"tile\\")}\\n    [\:h1 (first(str cell))]]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.view)\\n\\n(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\n            \:class (if (\= (second (str cell)) \\\\[)) \\n                     \\"tile inword\\" \\n                     \\"tile\\"}\\n    [\:h1 (first(str cell))]]])\\n\\n(clojure.core/ns lingo.repl)" "(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\r\\n            \:class (if (\= (second (str cell)) \\\\[)\\r\\n                     \\"tile inword\\" \\r\\n                     \\"tile\\")}\\r\\n    [\:h1 (first(str cell))]]])" "(clojure.core/ns lingo.view)\\n    [\:h1 (first(str cell))]]])\\n\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.view)\\n(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\r\\n            \:class (if (\= (second (str cell)) \\\\[)\\r\\n                     \\"tile inword\\" \\r\\n                     \\"tile\\")}\\r\\n    [\:h1 (first(str cell))]]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.view)\\n(defn cell-html [rownum colnum cell] \\r\\n  [\:td \\r\\n   [\:div {\:name (str \\"b\\" rownum colnum) \\r\\n            \:value (str cell)\\r\\n            \:class (if (\= (second (str cell)) \\\\])\\r\\n                     \\"tile inword\\" \\r\\n                     \\"test\\")}\\r\\n    [\:h1 (first(str cell))]]])\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.view namespace" "(start-server)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn is-in-correct-place? [located-letter the-word]\\n  (let [[char x] located-letter]\\n    (\= (.charAt (clojure.string/capitalize the-word) x) (clojure.string/capitalize char))))\\n\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(defn contains-char? [the-char, the-string]\\n  (some \#(\= (clojure.string/capitalize the-char) %) (clojure.string/capitalize the-string)))\\n(clojure.core/ns lingo.repl)" ";; Switching to lingo.repl namespace" "(start-server)" "(clojure.core/ns lingo.model)\\n(def init-board [[(str(clojure.string/upper-case(first(get-word)) \\\\[)) \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(clojure.core/ns lingo.model)\\n(def init-board [[(str(clojure.string/upper-case(first(get-word)) )\\\\[) \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n(clojure.core/ns lingo.repl)" "(lingo.model/word-with-correctness \\"linho\\")" "(lingo.model/correct-letters \\"linho\\" \\"lingo\\")" "(\= (.charAt (clojure.string/capitalize \\"a\\") x) (clojure.string/capitalize \\\\a))" "(\= (.charAt (clojure.string/capitalize \\\\a) x) (clojure.string/capitalize \\\\a))" "(\= (.charAt (clojure.string/capitalize \\\\a) 0) (clojure.string/capitalize \\\\a))" "(clojure.string/capitalize \\\\a)" "(\= (.charAt (clojure.string/capitalize \\"wiird\\") 1) (clojure.string/capitalize \\\\i)" "(\= (.charAt (clojure.string/capitalize \\"wiird\\") 1) (clojure.string/capitalize \\\\i))" "(.charAt (clojure.string/capitalize \\"wiird\\") 1)" "(clojure.string/capitalize \\"wiird\\")" ";; Switching to lingo.repl namespace" "(start-server)" "(\= (.charAt (clojure.string/lower-case \\"WOORD\\") 2) (clojure.string/lower-case o))" "(\= (.charAt (clojure.string/lower-case \\"WOORD\\") 2) (clojure.string/lower-case \\\\o))" "(clojure.string/lower-case \\"WOORD\\")" "(.charAt (clojure.string/lower-case \\"WOORD\\") 2)" "(clojure.string/lower-case \\\\o)" "(clojure.core/ns lingo.model)\\n(defn is-in-correct-place? [located-letter the-word]\\n  (let [[char x] located-letter]\\n    (\= (str (.charAt (clojure.string/lower-case the-word) x) \\n            (clojure.string/lower-case char)))))\\n(clojure.core/ns lingo.repl)" "(some \#(\= (clojure.string/lower-case the-char) %) (clojure.string/lower-case the-string)))" "(some \#(\= (clojure.string/lower-case the-char) %) (clojure.string/lower-case the-string))" "(some \#(\= (clojure.string/lower-case \\\\A ) %) (clojure.string/lower-case the-string))" "(some \#(\= (clojure.string/lower-case \\\\A ) %) (clojure.string/lower-case \\"a\\"))" "(some \#(\= (clojure.string/lower-case \\\\A ) %) (clojure.string/lower-case \\"A\\"))" "(clojure.string/lower-case \\"A\\")" "(clojure.string/lower-case \\\\A )" "(clojure.core/ns lingo.model)\\n(defn contains-char? [the-char, the-string]\\n  (some \#(\= (clojure.string/lower-case the-char) %) (clojure.string/lower-case the-string)))\\r\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/contains-char? /A \\"aap\\")" "(lingo.model/contains-char? \\\\A \\"aap\\")" "(lingo.model/contains-char? \\"a\\" \\"aap\\")" "(clojure.core/ns lingo.model)\\n\\n(defn contains-char? [the-char, the-string]\\r\\n         (some \#(\= the-char %) the-string))\\n(clojure.core/ns lingo.repl)" "(lingo.model/contains-char? \\"a\\" \\"aap\\")" "(lingo.model/contains-char? \\\\a \\"aap\\")" "(clojure.core/ns lingo.model)\\n(defn contains-char? [the-char, the-string]\\r\\n         (some \#(\= (.charAt (clojure.string/lower-case the-char) 0) %) (clojure.string/lower-case the-string)))\\r\\n\\n(clojure.core/ns lingo.repl)" "(lingo.model/contains-char? \\\\A \\"aap\\")" "(lingo.model/contains-char? \\\\A \\"AAp\\")" ";; Switching to lingo.repl namespace" "(start-server)" "\\r\\n         (some \#(\= (.charAt (clojure.string/lower-case \\\\h) 0) %) (clojure.string/lower-case \\"lingo\\"))" "\\r\\n         (some \#(\= (.charAt (clojure.string/lower-case \\\\g) 0) %) (clojure.string/lower-case \\"lingo\\"))" "(lingo.model/word-with-correctness \\"linho\\")" "(lingo.model/word-with-correctness \\"lihno\\")" "(lingo.model/correct-letters \\"lihno\\" \\"lingo\\")" "(lingo.model/letters-in-word \\"lihno\\" \\"lingo\\")" "(lingo.model/correct-letters \\"lihno\\" \\"lingo\\")" "(str (.charAt (clojure.string/lower-case \\"lingo\\") 2) )" "(clojure.string/lower-case \\\\n)" "(clojure.string/lower-case \\"n\\n\\")" "(clojure.string/lower-case \\"n\\")" "\\r\\n  (for [x (combine-into-located-letters \\"lihno\\")]\\r\\n    (is-in-correct-place? x \\"lingo\\"))" "\\r\\n(for [x (lingo.model\\\\combine-into-located-letters \\"lihno\\")]\\r\\n    (lingo.model\\\\is-in-correct-place? x \\"lingo\\"))" "\\r\\n(for [x (lingo.model/combine-into-located-letters \\"lihno\\")]\\r\\n    (lingo.model/is-in-correct-place? x \\"lingo\\"))" "(lingo.model/combine-into-located-letters \\"lihno\\")" "\\r\\n(lingo.model/is-in-correct-place? [\\\\i 1] \\"lingo\\")" "\\r\\n(lingo.model/is-in-correct-place? [\\\\i 3] \\"lingo\\")" "(clojure.core/ns lingo.model)\\n\\n(defn is-in-correct-place? [located-letter the-word]\\n  (let [[char x] located-letter]\\n    (\= (str (.charAt (clojure.string/lower-case the-word) x)) \\n       (clojure.string/lower-case char))))\\n(clojure.core/ns lingo.repl)" "\\r\\n(lingo.model/is-in-correct-place? [\\\\i 3] \\"lingo\\")" "\\r\\n(lingo.model/is-in-correct-place? [\\\\i 2] \\"lingo\\")" "\\r\\n(lingo.model/is-in-correct-place? [\\\\i \\n                                   1] \\"lingo\\")"]
eclipse.preferences.version=1
